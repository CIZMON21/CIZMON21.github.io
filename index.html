<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; background: #0a0a0a; overflow: hidden; }
        canvas { cursor: none; }
    </style>
</head>
<body>
    <canvas id="dragonCanvas"></canvas>

    <script>
        const canvas = document.getElementById('dragonCanvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const DRAGON = {
            segments: [],
            segmentCount: 28,
            baseSpeed: 0.15,
            bodyWave: 0,
            wingFlap: 0,
            physics: {
                stiffness: 0.2,
                damping: 0.92,
                mass: 1.2
            }
        };

        // Responsive setup
        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            DRAGON.segments = Array.from({ length: DRAGON.segmentCount }, (_, i) => ({
                x: canvas.width/2,
                y: canvas.height/2 - i * 18,
                vx: 0,
                vy: 0
            }));
        }
        window.addEventListener('resize', initCanvas);
        initCanvas();

        // Mouse tracking
        const mouse = { x: canvas.width/2, y: canvas.height/2 };
        canvas.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // Realistic bone rendering
        function drawBone(x1, y1, x2, y2, width) {
            ctx.beginPath();
            ctx.strokeStyle = `hsl(0, 0%, ${90 - (width * 2)}%)`;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        // Enhanced skull with temporal bones
        function drawSkull(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Cranium
            ctx.beginPath();
            ctx.arc(0, 0, 24, 0, Math.PI * 2);
            ctx.fillStyle = '#f0f0f0';
            ctx.fill();
            
            // Jaw
            ctx.beginPath();
            ctx.arc(0, 14, 18, 0.2, Math.PI - 0.2);
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Nasal cavity
            ctx.beginPath();
            ctx.ellipse(0, -6, 8, 4, 0, 0, Math.PI * 2);
            ctx.fillStyle = '#2a2a2a';
            ctx.fill();
            
            ctx.restore();
        }

        // Physics-based movement
        function updateDragon() {
            DRAGON.bodyWave = (DRAGON.bodyWave + 0.03) % (Math.PI * 2);
            DRAGON.wingFlap = Math.sin(Date.now()/200) * 0.7;

            DRAGON.segments.forEach((seg, i) => {
                const target = i === 0 ? mouse : DRAGON.segments[i-1];
                const dx = target.x - seg.x;
                const dy = target.y - seg.y;
                const distance = Math.hypot(dx, dy);
                
                // Prevent division by zero
                if (distance > 0) {
                    const force = DRAGON.physics.stiffness * (i === 0 ? 0.25 : 1);
                    seg.vx += (dx / distance) * force;
                    seg.vy += (dy / distance) * force;
                }

                // Body undulation
                if (i > 3) {
                    seg.vx += Math.sin(DRAGON.bodyWave + i * 0.3) * 0.15;
                    seg.vy += Math.cos(DRAGON.bodyWave + i * 0.3) * 0.1;
                }

                // Velocity damping
                seg.vx *= DRAGON.physics.damping;
                seg.vy *= DRAGON.physics.damping;
                
                seg.x += seg.vx;
                seg.y += seg.vy;
            });
        }

        // Realistic wing structure
        function drawWings(baseX, baseY) {
            ctx.save();
            ctx.translate(baseX, baseY);
            
            const flapAngle = DRAGON.wingFlap * Math.PI/3;
            for (let i = 0; i < 3; i++) {
                const wingLength = 100 - i * 20;
                const segmentAngle = flapAngle * (0.8 + i * 0.1);
                
                // Right wing
                drawBone(0, 0, 
                    Math.cos(-segmentAngle) * wingLength,
                    Math.sin(-segmentAngle) * wingLength,
                    12 - i * 2
                );
                
                // Left wing
                drawBone(0, 0, 
                    Math.cos(Math.PI + segmentAngle) * wingLength,
                    Math.sin(Math.PI + segmentAngle) * wingLength,
                    12 - i * 2
                );
            }
            ctx.restore();
        }

        // Main animation loop
        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updateDragon();
            
            // Draw spine
            DRAGON.segments.forEach((seg, i) => {
                if (i > 0) {
                    const prev = DRAGON.segments[i-1];
                    drawBone(prev.x, prev.y, seg.x, seg.y, 20 - i * 0.6);
                }
            });

            // Draw wings
            drawWings(DRAGON.segments[4].x, DRAGON.segments[4].y);
            drawSkull(DRAGON.segments[0].x, DRAGON.segments[0].y);
            
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
